package main

func twoSum(nums []int, target int) []int {
	numMap := make(map[int]int)
	for i, num := range nums {
		compl := target - num
		if j, found := numMap[compl]; found {
			return []int{j, i}
		}
		numMap[num] = i
	}
	return []int{}
}

// Объяснение алгоритма:

// 1. Мы создаем хеш-таблицу `numMap`, которая будет хранить числа из массива `nums` в качестве ключей и их индексы в качестве значений.

// 2. Затем мы проходим по массиву `nums`. Для каждого числа `num`:
//    - Вычисляем дополнение `complement = target - num`.
//    - Проверяем, есть ли это дополнение уже в нашей хеш-таблице.
//    - Если есть, мы нашли решение и возвращаем индексы: индекс дополнения из хеш-таблицы и текущий индекс.
//    - Если нет, добавляем текущее число и его индекс в хеш-таблицу.

// 3. Если мы прошли весь массив и не нашли решения, возвращаем пустой слайс (хотя по условиям задачи это не должно произойти, так как гарантируется наличие ровно одного решения).

// Этот алгоритм работает за O(n) времени, где n - длина массива nums, и использует O(n) дополнительной памяти для хеш-таблицы в худшем случае.

// Преимущества этого решения:
// - Оно эффективно по времени, так как проходит по массиву только один раз.
// - Использует хеш-таблицу для быстрого поиска дополнения, что дает константное время поиска в среднем случае.

// Это решение оптимально для данной задачи и широко используется на практике.
