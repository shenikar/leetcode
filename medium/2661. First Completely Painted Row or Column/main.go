package main

func firstCompleteIndex(arr []int, mat [][]int) int {
	m, n := len(mat), len(mat[0])
	numIndex := make(map[int][2]int)

	// Создаем карту для хранения позиций каждого числа в матрице
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			numIndex[mat[i][j]] = [2]int{i, j}
		}
	}

	rowCount := make([]int, m)
	colCount := make([]int, n)

	// Проходим по arr и отмечаем каждое число
	for i, num := range arr {
		pos := numIndex[num]
		rowCount[pos[0]]++
		colCount[pos[1]]++

		// Проверяем, заполнена ли полностью строка или столбец
		if rowCount[pos[0]] == n || colCount[pos[1]] == m {
			return i
		}
	}

	return -1 // Этот случай не должен произойти, если входные данные корректны
}

// Алгоритм
// Сначала мы создаем карту numIndex, которая хранит позиции каждого числа в матрице. Это позволит нам быстро находить позицию числа в матрице, когда мы будем проходить по массиву arr.
// 2. Мы создаем два слайса rowCount и colCount для подсчета количества отмеченных элементов в каждой строке и столбце соответственно.
// 3. Затем мы проходим по массиву arr. Для каждого числа:
// Находим его позицию в матрице с помощью numIndex.
// Увеличиваем счетчики для соответствующей строки и столбца.
// Проверяем, стала ли эта строка или столбец полностью заполненными.
// Если да, возвращаем текущий индекс в arr.
// 4.Если мы прошли весь массив и не нашли полностью заполненную строку или столбец, возвращаем -1 (хотя этого не должно произойти, если входные данные корректны).
// Этот алгоритм работает за O(mn + len(arr)) времени, где m и n - размеры матрицы, и использует O(mn) дополнительной памяти для хранения позиций чисел.
